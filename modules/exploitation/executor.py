"""
modules/exploitation/executor.py

Executor module for DXploit Step5.
- Presents recommended exploit tools to user
- Allows choosing which exploit to run
- Applies `mode` settings (normal/silent/brutal) to tool arguments
- Runs the selected tool (subprocess), streams output, saves logs

Dependencies (external tools must be installed on the system):
- sqlmap (cli)
- nuclei
- nikto
- ffuf (or dirsearch)
- patator (for bruteforce alternative to hydra)
- crackmapexec (CME)
- impacket tools (like smbclient.py, rpcclient.py) - invoked via impacket scripts
"""

from typing import List, Tuple, Dict, Any, Optional
import subprocess
import shlex
import os
import time
import json
from core.utils import now_iso, ensure_dir, save_json, safe_input

LOG_DIR = os.path.join("data", "exploit_logs")
ensure_dir(LOG_DIR)


# Map friendly tool key -> command builder function
def _sqlmap_cmd(target: str, mode: str, extra: Dict[str, Any]) -> List[str]:
    # target can be a URL or a parameter injection string
    cmd = ["sqlmap", "-u", target, "--batch", "--output-dir", LOG_DIR]
    if mode == "silent":
        cmd += ["--timeout=10", "--threads=1"]
    elif mode == "brutal":
        # aggressive options for sqlmap (use with care)
        cmd += ["--threads=10", "--flush-session"]
    # extra could include --data, --param, etc
    if extra.get("data"):
        cmd += ["--data", extra["data"]]
    if extra.get("cookie"):
        cmd += ["--cookie", extra["cookie"]]
    return cmd


def _nuclei_cmd(target: str, mode: str, extra: Dict[str, Any]) -> List[str]:
    cmd = ["nuclei", "-target", target, "-o", os.path.join(LOG_DIR, f"nuclei_{target.replace('/', '_')}.txt")]
    if mode == "silent":
        cmd += ["-rl", "50"]  # rate-limit example
    elif mode == "brutal":
        cmd += ["-rl", "500"]
    # optionally use templates path
    if extra.get("templates"):
        cmd += ["-t", extra["templates"]]
    return cmd


def _nikto_cmd(target: str, mode: str, extra: Dict[str, Any]) -> List[str]:
    cmd = ["nikto", "-h", target, "-o", os.path.join(LOG_DIR, f"nikto_{target}.txt")]
    if mode == "silent":
        cmd += ["-Tuning", "b"]  # reduce checks (example)
    return cmd


def _ffuf_cmd(target: str, mode: str, extra: Dict[str, Any]) -> List[str]:
    # ffuf expects URL fuzzing pattern like http://host/FUZZ
    pattern = extra.get("pattern") or f"{target}/FUZZ"
    wordlist = extra.get("wordlist") or "/usr/share/wordlists/dirb/common.txt"
    out = os.path.join(LOG_DIR, f"ffuf_{target.replace('://','_')}.json")
    cmd = ["ffuf", "-u", pattern, "-w", wordlist, "-o", out, "-of", "json"]
    if mode == "silent":
        cmd += ["-t", "5"]
    elif mode == "brutal":
        cmd += ["-t", "50"]
    return cmd


def _patator_ssh_cmd(target: str, mode: str, extra: Dict[str, Any]) -> List[str]:
    # patator ssh_login host=HOST user=FILE password=FILE -x ignore:code=1
    userfile = extra.get("userfile") or "/usr/share/wordlists/users.txt"
    passfile = extra.get("passfile") or "/usr/share/wordlists/rockyou.txt"
    cmd = ["patator", "ssh_login", f"host={target}", f"user={userfile}", f"password={passfile}", "ssh_timeout=5", "log=patator_ssh.log"]
    if mode == "silent":
        cmd += ["--rate", "1"]
    elif mode == "brutal":
        cmd += ["--rate", "50"]
    return cmd


def _cme_smb_cmd(target: str, mode: str, extra: Dict[str, Any]) -> List[str]:
    # CME example: cme smb <target> -u user -p pass --shares
    cmd = ["crackmapexec", "smb", target, "--shares"]
    if extra.get("username") and extra.get("password"):
        cmd += ["-u", extra["username"], "-p", extra["password"]]
    if mode == "silent":
        cmd += ["--no-bruteforce"]
    return cmd


def _impacket_wrapped_cmd(script_name: str, target: str, mode: str, extra: Dict[str, Any]) -> List[str]:
    # Example for impacket script invocation (smbclient.py etc)
    script_path = script_name  # assume in PATH (impacket install provides these)
    cmd = [script_path, target]
    if extra.get("username"):
        cmd += ["-u", extra["username"]]
    if extra.get("password"):
        cmd += ["-p", extra["password"]]
    return cmd


# Tool registry: maps tool-key to command builder and friendly name
TOOL_REGISTRY = {
    "sqlmap": (_sqlmap_cmd, "sqlmap (automatic SQL injection & dump)"),
    "nuclei": (_nuclei_cmd, "nuclei (template-based vuln scanner)"),
    "nikto": (_nikto_cmd, "Nikto (web server scanner)"),
    "ffuf": (_ffuf_cmd, "ffuf (directory & fuzzing)"),
    "patator_ssh": (_patator_ssh_cmd, "Patator (SSH brute alternative to Hydra)"),
    "cme_smb": (_cme_smb_cmd, "CrackMapExec (SMB/AD enumeration & actions)"),
    "impacket_smbclient": (lambda t, m, e: _impacket_wrapped_cmd("smbclient.py", t, m, e), "Impacket smbclient (SMB file ops)"),
}


def available_tools() -> List[str]:
    return list(TOOL_REGISTRY.keys())


# Runner that spawns subprocess and streams output to terminal & file
def _run_subprocess_stream(cmd: List[str], log_basename: str) -> Dict[str, Any]:
    """
    Run subprocess with streaming stdout/stderr, save full output to log files.
    Returns dict with exit_code, stdout_path, stderr_path.
    """
    safe_cmd = [str(x) for x in cmd]
    stdout_path = os.path.join(LOG_DIR, f"{log_basename}.out")
    stderr_path = os.path.join(LOG_DIR, f"{log_basename}.err")
    # open log files
    with open(stdout_path, "w", encoding="utf-8", errors="ignore") as so, open(stderr_path, "w", encoding="utf-8", errors="ignore") as se:
        print(f"[+] Executing: {' '.join(shlex.quote(c) for c in safe_cmd)}")
        proc = subprocess.Popen(safe_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, bufsize=1)
        # stream stdout
        while True:
            out_line = proc.stdout.readline()
            err_line = proc.stderr.readline()
            if out_line:
                print(out_line.rstrip())
                so.write(out_line)
            if err_line:
                print(err_line.rstrip())
                se.write(err_line)
            if out_line == "" and err_line == "" and proc.poll() is not None:
                break
            # tiny sleep to avoid busy-loop
            time.sleep(0.01)
        exit_code = proc.returncode
    return {"exit_code": exit_code, "stdout": stdout_path, "stderr": stderr_path}


def choose_tool_and_run(recommendations: List[Tuple[str, str]], target: str, mode: str):
    """
    recommendations: list of (tool_key, reason)
    target: ip or url
    mode: normal|silent|brutal
    """
    print("\n[+] Recommendations:")
    for i, (tool, reason) in enumerate(recommendations, start=1):
        print(f" [{i}] {tool} -> {reason}")

    choice = safe_input("Pilih tool untuk dijalankan (angka) atau 'n' untuk skip: ").strip()
    if choice.lower() == "n":
        print("[*] Skip exploit execution.")
        return None

    try:
        idx = int(choice) - 1
        if not (0 <= idx < len(recommendations)):
            print("[!] Pilihan tidak valid.")
            return None
    except ValueError:
        print("[!] Pilihan tidak valid.")
        return None

    selected_tool = recommendations[idx][0]
    if selected_tool not in TOOL_REGISTRY:
        print(f"[!] Tool {selected_tool} tidak tersedia di registry.")
        return None

    # confirm mode brutal explicitly
    if mode == "brutal":
        confirm = safe_input("Brutal mode selected. Type YES to confirm and continue: ").strip()
        if confirm != "YES":
            print("[!] Brutal mode aborted by user.")
            return None

    # ask for extra params depending on tool
    extra = {}
    if selected_tool == "sqlmap":
        # ask if target is URL or injection string; allow --data or cookie
        data = safe_input("Jika ada POST data, masukkan di sini (atau enter): ").strip()
        cookie = safe_input("Jika perlu cookie, masukkan di sini (atau enter): ").strip()
        if data:
            extra["data"] = data
        if cookie:
            extra["cookie"] = cookie
    elif selected_tool == "ffuf":
        pattern = safe_input("Masukkan pattern URL (contoh: http://target/FUZZ) [default]: ").strip()
        if pattern:
            extra["pattern"] = pattern
        wl = safe_input("Masukkan path wordlist (atau enter default): ").strip()
        if wl:
            extra["wordlist"] = wl
    elif selected_tool in ("patator_ssh", "cme_smb", "impacket_smbclient"):
        user = safe_input("Jika ingin memakai username, isi di sini (enter untuk skip): ").strip()
        pwd = safe_input("Jika ingin memakai password, isi di sini (enter untuk skip): ").strip()
        if user:
            extra["username"] = user
        if pwd:
            extra["password"] = pwd

    # build command
    cmd_builder, friendly = TOOL_REGISTRY[selected_tool]
    cmd = cmd_builder(target, mode, extra)
    # create log basename
    log_basename = f"{selected_tool}_{target.replace(':','_')}_{now_iso().replace(':','-')}"
    # run
    res = _run_subprocess_stream(cmd, log_basename)
    # save run metadata
    meta = {
        "tool": selected_tool,
        "friendly": friendly,
        "target": target,
        "mode": mode,
        "cmd": cmd,
        "result": res,
        "timestamp": now_iso()
    }
    meta_path = os.path.join(LOG_DIR, f"{log_basename}.meta.json")
    save_json(meta_path, meta)
    print(f"[+] Execution finished. Logs: {res['stdout']}, {res['stderr']}. Meta: {meta_path}")
    return meta


# Convenience wrapper to accept service_info (from mapper)
def run_for_service(service_info: Dict[str, Any], recommendations: List[Tuple[str, str]], mode: str):
    """
    service_info: dict containing 'port', 'service', 'product', ...
    recommendations: list of (tool_key, reason) as strings
    """
    target = service_info.get("target") or service_info.get("host") or service_info.get("ip") or service_info.get("address")
    if target is None:
        print("[!] No target information in service_info.")
        return None
    # present recommendations and run
    return choose_tool_and_run(recommendations, target, mode)
